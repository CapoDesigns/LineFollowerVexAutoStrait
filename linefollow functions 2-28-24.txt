#pragma config(Sensor, in1,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in2,    centerLineFollower, sensorLineFollower)
#pragma config(Sensor, in3,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, in6,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  sonarSensor,    sensorSONAR_inch)
#pragma config(Sensor, dgtl10, touchSensor,    sensorTouch)
#pragma config(Sensor, dgtl11, armEncoder,     sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  rightIME,       sensorNone)
#pragma config(Sensor, I2C_2,  leftIME,        sensorNone)
#pragma config(Sensor, I2C_3,  armIME,         sensorNone)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393TurboSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           leftMotoBack,  tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightMotorBack, tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           armMotor,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
task follolw(){
	int contBreak = 0;
	while(contBreak == 0)
		if(SensorValue[centerLineFollower]>2600){
		setMotor(port1, 127);
		setMotor(port2, 127);
		setMotor(port3, 105);
		setMotor(port10, 105);
		if(vexRT[Btn7R] == 1){
		contBreak = 0;
			}
		}else{
		setMotor(port1, 50);
		setMotor(port2, 50);
		setMotor(port3, 50);
		setMotor(port10, 50);
		if(vexRT[Btn7R] == 1){
				contBreak = 0;
			}
		waitUntil(SensorValue[leftLineFollower]>2800 || SensorValue[rightLineFollower]>2600);
		setMotor(port1, 0);
		setMotor(port2, 0);
		setMotor(port3, 0);
		setMotor(port10, 0);
		if(SensorValue[leftLineFollower]>2800){
			setMotor(port1, -110);
			setMotor(port2, -105);
			setMotor(port3, 105);
			setMotor(port10, 110);
			if(vexRT[Btn7R] == 1){
				contBreak = 0;
			}
			/*
			ADD BREAK TO WAIT UNTIL 
				ADD BREAK TO WAIT UNTIL 
					ADD BREAK TO WAIT UNTIL 
						ADD BREAK TO WAIT UNTIL 
							ADD BREAK TO WAIT UNTIL 
								ADD BREAK TO WAIT UNTIL 
									ADD BREAK TO WAIT UNTIL 
									*/
			waitUntil(SensorValue[centerLineFollower]>2600);
			setMotor(port1, 0);
			setMotor(port2, 0);
			setMotor(port3, 0);
			setMotor(port10, 0);
			if(vexRT[Btn7R] == 1){
				contBreak = 0;
			}
		}
		if(SensorValue[rightLineFollower]>2800){
			setMotor(port1, 127);
			setMotor(port2, 112);
			setMotor(port3, -113);
			setMotor(port10, -100);
			if(vexRT[Btn7R] == 1){
				contBreak = 0;
			}
			waitUntil(SensorValue[centerLineFollower]>2600);
			setMotor(port1, 0);
			setMotor(port2, 0);
			setMotor(port3, 0);
			setMotor(port10, 0);
			if(vexRT[Btn7R] == 1){
				contBreak = 0;
			}
		}
	}
}

task main()
{
	int stask = 0;
	while(true){
		if(vexRT[Btn7L] == 1){
			stask = 1;	
		}
		if(stask == 1){
			if(vexRT[Btn7D] == 1){
				startTask(follolw);
			}
		}

	}
}

